Metadata-Version: 2.4
Name: silicon-intelligence
Version: 0.1.0
Summary: Advanced AI-powered physical implementation system for IC design
Author: Silicon Intelligence Team
Author-email: Silicon Intelligence Team <team@silicon-intelligence.ai>
License: MIT
Requires-Python: >=3.8
Description-Content-Type: text/markdown
Requires-Dist: numpy>=1.21.0
Requires-Dist: networkx>=2.8.0
Requires-Dist: pandas>=1.4.0
Requires-Dist: matplotlib>=3.5.0
Requires-Dist: seaborn>=0.11.0
Requires-Dist: scikit-learn>=1.1.0
Requires-Dist: pyyaml>=6.0
Requires-Dist: tqdm>=4.64.0
Provides-Extra: dev
Requires-Dist: pytest>=7.0.0; extra == "dev"
Requires-Dist: black>=22.0.0; extra == "dev"
Requires-Dist: flake8>=4.0.0; extra == "dev"
Requires-Dist: mypy>=0.950; extra == "dev"
Requires-Dist: jupyter>=1.0.0; extra == "dev"
Dynamic: author
Dynamic: requires-python

# Silicon Intelligence System

An advanced AI-powered physical implementation system for integrated circuit (IC) design, designed to revolutionize the chip design process from RTL to GDSII.

## Vision

This system transforms traditional EDA tools from procedural engines into intelligent silicon architects that can reason about design intent, predict physical implementation challenges, and optimize for power, performance, and area (PPA) across advanced process nodes (16nm → 3nm and beyond).

The Silicon Intelligence System represents a paradigm shift from manual, iterative chip design to an intelligent, predictive, and self-improving system that learns from each design to make the next one smarter.

## Architecture Overview

### Cognitive Layer (GenAI Brain)
- **Design Intent Interpreter**: Understands high-level design goals and constraints
- **Silicon Knowledge Model**: Trained on millions of layouts, foundry rules, and failure cases
- **Reasoning Engine**: Uses chain-of-thought planning for complex optimization decisions

### Agentic Layer (Specialist AI Team)
- **Floorplan Agent**: Explores macro topologies and floorplan configurations
- **Placement Agent**: Congestion-aware and clock-aware placement optimization
- **Clock Agent**: Skew and variation-focused clock tree synthesis
- **Power Agent**: IR drop and EM optimization for power integrity
- **Yield Agent**: Defect sensitivity reduction and manufacturability optimization

### Parallel Reality Engine
- Multiple layout hypotheses running concurrently
- Early pruning of unsuccessful paths based on predictive models
- Resource allocation based on promise and success probability
- Evolutionary approach to design exploration

## Key Features

- **Intent-driven design** rather than procedural steps - designers declare what they want, AI decides how to achieve it
- **Predictive physical risk assessment** before layout exists - identifies congestion, timing, power, and DRC issues upfront
- **Canonical Silicon Graph** for unified representation across all design aspects
- **Agent negotiation protocol** for collaborative optimization between specialists
- **Learning loop from silicon data** - each chip makes the next one smarter
- **Full-flow integration** from RTL to GDSII with intelligent decision-making
- **DRC prediction and prevention** - avoids violations before they occur
- **Continuous model improvement** through post-silicon feedback

## System Components

### Core Architecture
- `CanonicalSiliconGraph`: Unified representation for all design aspects
- `PhysicalRiskOracle`: Predicts implementation challenges before layout
- `AgentNegotiator`: Coordinates specialist agents and resolves conflicts
- `ParallelRealityEngine`: Runs multiple design hypotheses concurrently
- `DRCPredictor`: Predicts and prevents design rule violations
- `LearningLoopController`: Updates models with silicon feedback

### Specialist Agents
- `FloorplanAgent`: Macro topology optimization
- `PlacementAgent`: Congestion-aware placement
- `ClockAgent`: Skew and variation-focused CTS
- `PowerAgent`: IR drop and EM optimization
- `YieldAgent`: Defect sensitivity reduction

### Data Processing
- `RTLParser`: Parses RTL for graph construction
- `CongestionPredictor`: Predicts routing congestion
- `TimingAnalyzer`: Analyzes timing paths and risks
- `OpenROADInterface`: Integration with baseline P&R engine

## Getting Started

### Installation
```bash
# Clone the repository
git clone <repository-url>
cd silicon-intelligence

# Install dependencies
pip install -r requirements.txt
```

### Basic Usage
```bash
# Run the physical risk oracle to predict challenges
python main.py --mode oracle --rtl my_design.v --constraints constraints.sdc --node 7nm

# Run agent negotiation
python main.py --mode agent --rtl my_design.v --constraints constraints.sdc --node 7nm

# Run full AI-driven flow
python main.py --mode full_flow --rtl my_design.v --constraints constraints.sdc --node 7nm --output-dir ./results

# Run comprehensive demo
python main.py --mode demo
```

### Example Usage
```python
from silicon_intelligence.main import run_full_flow

# Run the complete flow programmatically
run_full_flow(
    rtl_file="path/to/design.v",
    constraints_file="path/to/constraints.sdc",
    node="7nm",
    output_dir="./output"
)
```

### Comprehensive Example
```bash
# Run the comprehensive example
cd examples
python comprehensive_example.py
```

## Advanced Features

### Parallel Reality Exploration
The system runs multiple optimization strategies simultaneously:
```python
from silicon_intelligence.core.parallel_reality_engine import ParallelRealityEngine

engine = ParallelRealityEngine(max_workers=4)
universes = engine.run_parallel_execution(
    base_graph,
    strategy_generators,
    max_iterations=5
)
best_universe = engine.get_best_universe()
```

### DRC-Aware Optimization
Prevents design rule violations before they occur:
```python
from silicon_intelligence.models.drc_predictor import DRCPredictor, DRCAwarePlacer

drc_predictor = DRCPredictor()
drc_aware_placer = DRCAwarePlacer(drc_predictor)
optimized_graph = drc_aware_placer.place_with_drc_awareness(graph, "7nm")
```

### Learning Loop
Incorporates post-silicon feedback to improve future designs:
```python
from silicon_intelligence.core.learning_loop import LearningLoopController

controller = LearningLoopController()
controller.process_new_silicon_data(design_data)
controller.update_all_models(congestion_predictor, timing_analyzer, drc_predictor, agents)
```

## Project Structure

```
silicon-intelligence/
├── agents/                 # Specialist AI agents
│   ├── base_agent.py      # Base agent interface and negotiation protocol
│   ├── floorplan_agent.py # Floorplan optimization agent
│   ├── placement_agent.py # Placement optimization agent
│   ├── clock_agent.py     # Clock tree synthesis agent
│   ├── power_agent.py     # Power optimization agent
│   └── yield_agent.py     # Yield and manufacturability agent
├── cognitive/             # GenAI brain components
│   ├── physical_risk_oracle.py  # Predicts physical implementation risks
│   ├── design_intent_interpreter.py  # Interprets design intent
│   └── reasoning_engine.py           # Chain-of-thought reasoning
├── core/                  # Core system components
│   ├── canonical_silicon_graph.py    # Unified graph representation
│   ├── flow_orchestrator.py          # Advanced flow management
│   ├── parallel_reality_engine.py    # Parallel hypothesis execution
│   ├── openroad_interface.py         # OpenROAD integration
│   └── learning_loop.py              # Silicon feedback integration
├── data/                  # Data processing and training utilities
│   └── rtl_parser.py                 # Parses RTL for graph representation
├── models/                # ML models and prediction systems
│   ├── congestion_predictor.py       # Predicts routing congestion
│   ├── timing_analyzer.py            # Timing analysis model
│   └── drc_predictor.py              # Design rule violation prediction
├── utils/                 # Utility functions
│   ├── logger.py                     # Logging utilities
│   ├── visualization.py              # System visualization
│   └── metrics.py                    # PPA metric calculations
├── examples/              # Example implementations and demonstrations
│   └── comprehensive_example.py      # Full system demonstration
├── main.py                # Main entry point
├── requirements.txt       # Python dependencies
└── README.md              # This file
```

## Philosophy

The Silicon Intelligence System embodies a fundamental shift in chip design philosophy:

1. **From Procedural to Intent-Driven**: Instead of specifying how to implement, designers declare what they want to achieve
2. **From Reactive to Predictive**: Instead of fixing problems after they occur, the system predicts and prevents them
3. **From Isolated Steps to Integrated Thinking**: Instead of separate floorplan/place/route steps, the system thinks holistically
4. **From Static Tools to Learning Systems**: Instead of fixed algorithms, the system improves with each design

## Impact

This system addresses key challenges in modern chip design:
- **Complexity**: Manages the exponential complexity of advanced nodes
- **Iteration**: Reduces the painful cycle of "implement → analyze → fix → rerun"
- **Expertise**: Makes expert-level optimizations accessible to all designers
- **Time-to-market**: Dramatically reduces design cycle time
- **Quality**: Improves PPA outcomes through intelligent optimization

## Future Roadmap

- Integration with commercial EDA tools
- Support for additional process nodes (3nm, 2nm, and beyond)
- Enhanced machine learning models trained on more data
- Hardware acceleration for faster optimization
- Cloud-based parallel processing capabilities

## Contributing

We welcome contributions to the Silicon Intelligence System. Please see our contributing guidelines for more information.

## License

This project is licensed under the MIT License - see the LICENSE file for details.

## Acknowledgments

The Silicon Intelligence System builds upon decades of EDA innovation and represents the next evolution in chip design automation.
